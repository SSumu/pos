package com.springbootacademy.batch7.pos.repo;

import com.springbootacademy.batch7.pos.entity.Customer;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
@EnableJpaRepositories
public interface CustomerRepo extends JpaRepository<Customer,Integer> {
//    List<Customer> findgsergnjergkrenj(boolean activeState); // The Repo or the Repository is an interface. It is not needed to write queries but there are some situations that we have to write queries. We have to access the database from the repository. We do not want to write queries for save functions, updates, get, and delete. We inherit by using extends keyword. Here the inheritance is used and one of the place inheritance is used in Spring. If extends keyword is used in somewhere, there the inheritance is used. So CustomerRepo inherited JpaRepository which means inheritance. Took Whole spec of JpaRepository to this using extends keyword.
// To Repository, Generics which means it has no type. We can dynamically assign types at the time. We can give types like Generics in this way.:- JpaRepository<T, ID>. <Left,Right> :- On the left side of this <Left,Right>, we put entity type or the entity name. On the right side of this <Left,Right>, we put type of the primary key of the entity has put on the left side. For the right side, even it is int, it must be integer. Applying <Customer,Integer> means the values of Customer is assigned to T and the value of Integer is assigned to ID in everywhere where the places of T and ID are used in the class files. The S which extends the T is also assigned from Customer. So it changes queries based on the entities I provide. Repository means the database. Data are passed through Entity from CustomerServiceIMPL to CustomerRepo. After we provide the database type as the Customer, we cannot deal by DTO from CustomerServiceIMPL to CustomerRepo. But the CustomerServiceIMPL has DTOs. Repo does not have a code, and we access the method which it has.

    List<Customer> findAllByActiveEquals(boolean activeState); // It asks us to create this method in the Repo when we type this method in the CustomerServiceIMPL because there is no such method in the customerRepo. There are another methods to do this. We erase the method. In here, we cannot type the names what we want manually. We can only type the names what suggsets in here. Here we create a query method like in the JpaRepository class. It is a customize query method. When we press crtl + space, it suggests us the methods what we can start from. First, we have to think whether the method is findBy(). But it is not findBy() because it gives only one thing if the method is findBy(). If we logically thinks, there it comes more data of customers not only one. So we take findAllBy. But we have to think findAllBy from what. findAllBy gives us fields of the entity of Customer. We can filter from that. Any parameter must be given first after the findAllBy. As there is an activeState as a parameter, so in that way. Let's think like there is another parameter like String name. Then we must give activeState at first and then the name. Do not type manually after findAllBy. Get the suggestions by ctrl + space. Here it shows as Active because there it  did not give as active_state in the entity. findAllByActiveEquals means send all the customers if Active equals the value(true or false) in the activeState parameter which the user has sent. By means filter. It means send all the customers after filtering if the values equals which I have sent. Here I created the query method. Now I can access this method from CustomerServiceIMPL.
}
